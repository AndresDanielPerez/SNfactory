import numpy as np
from scipy.integrate import quad
from scipy.stats import chi2, norm

from constants import Units,  Constants
from SNprofiles import SNprofiles_QCDALP

from scipy.interpolate import interp1d



class ALPphotonDET:
    def __init__(self, Cap, Deltat, diffSNfactor):
        self.mn = Constants.mn
        self.ee = Constants.ee
        
        self.stoMeVminus1 = Units.stoMeVminus1
        self.cmminus1toMeV = Units.cmminus1toMeV
        self.kpctocm = Units.kpctocm
        
        self.Cap = Cap
        self.Deltat = Deltat
        self.diffSNfactor = diffSNfactor
        


    def E_gamma_max(self, Ea, ma):
        return (ma**2 + 2 * Ea * self.mn) / (2 * (self.mn + Ea) - 2 * np.sqrt(Ea**2 - ma**2))

    def E_gamma_min(self, Ea, ma):
        return (ma**2 + 2 * Ea * self.mn) / (2 * (self.mn + Ea) + 2 * np.sqrt(Ea**2 - ma**2))

    def costheta0(self, E_gamma, Ea, ma, mA):
        return (2 * E_gamma * (mA + Ea) - 2 * mA * Ea - ma**2) / (2 * np.sqrt(Ea**2 - ma**2) * E_gamma)
        
        
    def M2(self, E_gamma, Ea, ma, ga):
        J = 1 / 2

        numerator = (2 * self.Cap**2 * self.ee**2 * ga**2 *
                     (E_gamma * ma**6 + ma**4 * (2 * Ea * E_gamma + ma**2) * self.mn +
                      4 * (Ea - E_gamma) * ma**2 * ((Ea - E_gamma) * E_gamma + ma**2) * self.mn**2 +
                      4 * (Ea - E_gamma)**2 * (2 * Ea * E_gamma + ma**2) * self.mn**3))

        denominator = (E_gamma**2 * (ma**2 + 2 * Ea * self.mn)**2 * (self.mn + 2 * J * self.mn))

        return numerator / denominator

    def dSigma_dEgamma(self, E_gamma, Ea, ma, ga):
        return (1 / (32 * np.pi * self.mn * (Ea**2 - ma**2))) * self.M2(E_gamma, Ea, ma, ga)
        

    def Eamin(self, Egamma, ma):
        # conditions, kinematics
        lower_bound = (-ma**2 + 2 * ma * self.mn) / (2 * self.mn)
        upper_bound = self.mn / 2

        if not (lower_bound < Egamma < upper_bound):
            return 0.0
            
        term1 = 2 * Egamma**2 * self.mn + ma**2 * self.mn
        term2 = Egamma * (-ma**2 - 2 * self.mn**2 + np.sqrt(ma**4 + 4 * ma**2 * (Egamma - self.mn) * self.mn + 4 * Egamma**2 * self.mn**2))
        return (term1 + term2) / (2 * (2 * Egamma - self.mn) * self.mn)

    def Eamax(self, Egamma, ma):
        # conditions, kinematics
        lower_bound = (-ma**2 + 2 * ma * self.mn) / (2 * self.mn)
        upper_bound = self.mn / 2

        if not (lower_bound < Egamma < upper_bound):
            return 0.0
            
        sqrt_term = np.sqrt(ma**4 + 4 * ma**2 * (Egamma - self.mn) * self.mn + 4 * Egamma**2 * self.mn**2)
        numerator = ((Egamma - self.mn) * (- ma**2 + 2 * Egamma * self.mn)) / (2 * Egamma - self.mn) + Egamma * sqrt_term / np.abs(2 * Egamma - self.mn)
        return numerator / (2 * self.mn)


    def dNgammadEgamma(self, Egamma, ma, ga, dNdEdt):
        """ dNγ/dEγ """
        integral_result, _ = quad(
            lambda Ea: max(0, dNdEdt(Ea, ma, ga)) * self.dSigma_dEgamma(Egamma, Ea, ma, ga) if Ea > ma else 0,
            self.Eamin(Egamma, ma),
            self.Eamax(Egamma, ma), 
            epsrel=1e-2, epsabs=1e-2
        )
        return self.cmminus1toMeV**2 * self.Deltat * self.diffSNfactor * integral_result


    def Zthobs(self, ma, ga, dNdEdt, Ntargets, exptime, bins, Bth, Nobs):
        """ 
        # ma: axion mass,
        # ga: axion coupling,
        # dNdEdt: ALP spectrum generated by a single SN as a function of Ea, ma, ga (internally computes dNgammadEgamma[Ea, ma, ga]),		
        # Ntargets: number of targets in the detector,
        # exptime: exposure time of the considered experimental RUN, in seconds,
        # bins: list of energy bins,
        # Bth: number of EXPECTED background events per bin,
        # Nobs: number of OBSERVED events per bin 
        """
        
        Sth = np.array([
            ((bins[i] + bins[i + 1]) / 2,
             quad(lambda x: Ntargets * exptime * self.stoMeVminus1 * self.dNgammadEgamma(x, ma, ga, dNdEdt), bins[i], bins[i + 1], epsrel=1e-2, epsabs=1e-2)[0]
             if bins[i] > ma else 0)
            for i in range(len(bins) - 1)
        ])

	# test statistic
        qmaOBS = 2 * np.sum((Bth[:, 1] + Sth[:, 1]) - Nobs[:, 1] +
                                Nobs[:, 1] * np.log(Nobs[:, 1] / (Bth[:, 1] + Sth[:, 1])))

        if len(bins) > 2:
            dof = len(bins) - 2
        else:
            dof = 1
        CL = 1 - chi2.cdf(qmaOBS, dof)
        
        ZmaOBS = np.abs(norm.ppf(CL))
        Zs = [99 if np.isinf(ZmaOBS) else ZmaOBS]

        return Zs
        
        
    def Zthexp(self, ma, ga, dNdEdt, Ntargets, exptime, bins, Bth):
        """ 
        # ma: axion mass,
        # ga: axion coupling,
        # dNdEdt: ALP spectrum generated by a single SN as a function of Ea, ma, ga (internally computes dNgammadEgamma[Ea, ma, ga]),		
        # Ntargets: number of targets in the detector,
        # exptime: exposure time of the considered experimental RUN, in seconds,
        # bins: list of energy bins,
        # Bth: number of EXPECTED background events per bin
        """
        
        Sth = np.array([
            ((bins[i] + bins[i + 1]) / 2,
             quad(lambda x: Ntargets * exptime * self.stoMeVminus1 * self.dNgammadEgamma(x, ma, ga, dNdEdt), bins[i], bins[i + 1], epsrel=1e-2, epsabs=1e-2)[0]
             if bins[i] > ma else 0)
            for i in range(len(bins) - 1)
        ])

	# test statistic
        qmaEXP = 2 * np.sum(Bth[:, 1] * np.log(Bth[:, 1] / (Bth[:, 1] + Sth[:, 1])) + Sth[:, 1])

        
        ZmaEXP = np.sqrt(qmaEXP)
        Zs = [99 if np.isinf(ZmaEXP) else ZmaEXP]

        return Zs
        
        
        
    def flux_1sim(self, dNdEdt_single, ma, ga, Erange):
        """
        Builds the function dflux/dE * t_exposure as the sum of each SN contribution
        for each energy range (E1, E2) and distance to Earth dSN.
        """
        # Erange to array
        Erange_arr = np.array(Erange)  # shape (N, 3)

        def total_dNdEdt(Ea):
        	Ea = np.atleast_1d(Ea)	
        	result = np.zeros_like(Ea, dtype=np.float64)

        	for i, ea in enumerate(Ea):	
        		total = 0.0
        		for E1, E2, dSN in Erange_arr:
        			if E1 <= ea <= E2:
        				try:
        					val = dNdEdt_single(ea, ma, ga)
        					weight = 1.0 / (4 * np.pi * (dSN * self.kpctocm)**2)  # dSN in kpc → cm
        					total += val * weight 
        				except Exception as e:
        				#	print(f"[⚠️ Error dNdEdt in Ea={ea:.4f}, ma={ma}]: {e}")
        					continue
        		result[i] = total * self.Deltat * self.stoMeVminus1 # cm^-2 MeV^-1
        	return result[0] if result.size == 1 else result

        return total_dNdEdt 
        
        
    def flux_1sim_BINS(self, Erange, Ebins, dNdEdt, ma, ga):
      """ computes how the flux would be reduced due to the distance [cm^-2] (BINNED), considering the contributions of EVERY SN in 1 SIMULATION """

      result_bins = [] # flux per bin

      for i in range(len(Ebins) - 1):
	      Ebin_min = Ebins[i]
	      Ebin_max = Ebins[i+1]

	      integral_bin = 0.0

	      for idx, (E1, E2, dSN) in enumerate(Erange):
	      	Eoverlap_min = max(E1, Ebin_min)
	      	Eoverlap_max = min(E2, Ebin_max)

	      	if Eoverlap_min < Eoverlap_max and Eoverlap_min > ma *1.05:
	      		integral, _ = quad(lambda Ea: dNdEdt(Ea, ma, ga) * (1 / ( (4*np.pi) * (dSN * self.kpctocm)**2 ) ), 
	      			Eoverlap_min,
                		Eoverlap_max, 
                		epsrel=1e-2, epsabs=1e-2 )
	      		integral_bin += integral

	      result_bins.append(integral_bin)

      return np.array(result_bins) * self.Deltat * self.stoMeVminus1 # cm^-2 MeV^-1


    def dNgammadEgamma_1sim(self, Egamma, ma, ga, dNdEdt, Erange):
      """ dNγ/dEγ considering all simulated SN """
      Eamin_val = self.Eamin(Egamma, ma)
      Eamax_val = self.Eamax(Egamma, ma)

      # If the range makes no sense, retunr 0
      if Eamin_val == 0 or Eamax_val == 0 or Eamin_val >= Eamax_val:
        return 0.0

      def integrand(Ea):
        if Ea < ma*1.05:
            return 0.0

        flux_sum = 0.0
        for E1, E2, dSN in Erange:
            if E1 <= Ea <= E2:
                flux = dNdEdt(Ea, ma, ga) * (1 / (4 * np.pi * (dSN * self.kpctocm)**2))  # cm⁻² MeV⁻¹ s⁻¹
                flux_sum += flux
        return flux_sum * self.dSigma_dEgamma(Egamma, Ea, ma, ga) # MeV^-2 s⁻¹

      integral_result, _ = quad(
        integrand,
        Eamin_val,
        Eamax_val,
        epsrel=1e-2,
        epsabs=1e-2
      )

      return self.cmminus1toMeV**2 * self.Deltat * integral_result # MeV^-1
      
      
    def dNgammadEgamma_1sim_BINS(self, Egamma_bins, ma, ga, dNdEdt, Erange):
      """ dNγ/dEγ considering all simulated SN """
      
      binned_vals = []
      
      for i in range(len(Egamma_bins) - 1):
        Ebin_min, Ebin_max = Egamma_bins[i], Egamma_bins[i+1]
      	
        # Integrate dNgammadEgamma_1sim entre E1 y E2
        integral, _ = quad(lambda E: self.dNgammadEgamma_1sim(E, ma, ga, dNdEdt, Erange ), 
                       			Ebin_min, Ebin_max, epsrel=1e-2, epsabs=1e-2)
                       			
        binned_vals.append(integral / (Ebin_max - Ebin_min))
        
      return np.array(binned_vals)
      
      
    def Zthobs_1sim(self, ma, ga, dNdEdt, Ntargets, exptime, bins, Bth, Nobs, Erange):
        """ 
        # ma: axion mass,
        # ga: axion coupling,
        # dNdEdt: ALP spectrum generated by a single SN as a function of Ea, ma, ga (internally computes dNgammadEgamma[Ea, ma, ga]),		
        # Ntargets: number of targets in the detector,
        # exptime: exposure time of the considered experimental RUN, in seconds,
        # bins: list of energy bins,
        # Bth: number of EXPECTED background events per bin,
        # Nobs: number of OBSERVED events per bin 
        """
        
        Sth = Ntargets * exptime * self.stoMeVminus1 * self.dNgammadEgamma_1sim_BINS(bins, ma, ga, dNdEdt, Erange)

	# test statistic
        qmaOBS = 2 * np.sum((Bth[:, 1] + Sth) - Nobs[:, 1] +
                                Nobs[:, 1] * np.log(Nobs[:, 1] / (Bth[:, 1] + Sth)))

        if len(bins) > 2:
            dof = len(bins) - 2
        else:
            dof = 1
        CL = 1 - chi2.cdf(qmaOBS, dof)
        
        ZmaOBS = np.abs(norm.ppf(CL))
        Zs = [99 if np.isinf(ZmaOBS) else ZmaOBS]

        return Zs
      
      
      
      
            
      
    def dNgammadEgammaSimBINSXX(self, Egamma, ma, ga, dNdEdt):
      """ dNγ/dEγ """
      integral_result, _ = quad(
            lambda Ea: max(0, dNdEdt(Ea, ma, ga)) * self.dSigma_dEgamma(Egamma, Ea, ma, ga) if Ea > ma else 0,
            self.Eamin(Egamma, ma),
            self.Eamax(Egamma, ma), 
            epsrel=1e-2, epsabs=1e-2
      )
      return self.cmminus1toMeV**2 * self.Deltat * self.diffSNfactor * integral_result
        
        
    def dNgammadEgamma1simBINS(self, Egamma, ma, ga, dNdEdt, Erange):
      """ dNγ/dEγ considering all simulated SN """
      Eamin_val = self.Eamin(Egamma, ma)
      Eamax_val = self.Eamax(Egamma, ma)

      # If the range makes no sense, retunr 0
      if Eamin_val == 0 or Eamax_val == 0 or Eamin_val >= Eamax_val:
        return 0.0

      def integrand(Ea):
        if Ea < ma*1.05:
            return 0.0

        flux_sum = 0.0
        for E1, E2, dSN in Erange:
            if E1 <= Ea <= E2:
                flux = dNdEdt(Ea, ma, ga) * (1 / (4 * np.pi * (dSN * self.kpctocm)**2))  # cm⁻² MeV⁻¹ s⁻¹
                flux_sum += flux
        return flux_sum * self.dSigma_dEgamma(Egamma, Ea, ma, ga) # MeV^-2 s⁻¹

      integral_result, _ = quad(
        integrand,
        Eamin_val,
        Eamax_val,
        epsrel=1e-2,
        epsabs=1e-2
      )

      return self.cmminus1toMeV**2 * self.Deltat * integral_result # MeV^-1
      
      
      
    def dNgammadEgamma_fast(self, Egamma, ma, ga, dfluxdE_total):

      Ea_min = self.Eamin(Egamma, ma)
      Ea_max = self.Eamax(Egamma, ma)
    
      if Ea_max <= Ea_min:
            return 0

      Eas = np.linspace(Ea_min, Ea_max, 80)
      sigma_vals = self.dSigma_dEgamma(Egamma, Eas, ma, ga)
      flux_vals = dfluxdE_total(Eas)

      integrand = sigma_vals * flux_vals * (Eas > ma)
      return self.cmminus1toMeV**2 * np.trapz(integrand, Eas)
      

      
      
    def ZthobsSIM(self, ma, ga, dNdEdt, Ntargets, exptime, bins, Bth, Nobs, Erange):
        """ 
        # ma: axion mass,
        # ga: axion coupling,
        # dNdEdt: ALP spectrum generated by a single SN as a function of Ea, ma, ga (internally computes dNgammadEgamma[Ea, ma, ga]),		
        # Ntargets: number of targets in the detector,
        # exptime: exposure time of the considered experimental RUN, in seconds,
        # bins: list of energy bins,
        # Bth: number of EXPECTED background events per bin,
        # Nobs: number of OBSERVED events per bin 
        """
        
        Sth = np.array([
            ((bins[i] + bins[i + 1]) / 2,
             quad(lambda x: Ntargets * exptime * self.stoMeVminus1 * self.dNgammadEgamma_1sim_BINS(x, ma, ga, dNdEdt, Erange), bins[i], bins[i + 1], epsrel=1e-1, epsabs=1e-1)[0]
             if bins[i] > ma*1.05 else 0)
            for i in range(len(bins) - 1)
        ])

	# test statistic
        qmaOBS = 2 * np.sum((Bth[:, 1] + Sth[:, 1]) - Nobs[:, 1] +
                                Nobs[:, 1] * np.log(Nobs[:, 1] / (Bth[:, 1] + Sth[:, 1])))

        if len(bins) > 2:
            dof = len(bins) - 2
        else:
            dof = 1
        CL = 1 - chi2.cdf(qmaOBS, dof)
        
        ZmaOBS = np.abs(norm.ppf(CL))
        Zs = [99 if np.isinf(ZmaOBS) else ZmaOBS]

        return Zs
        
        
        
    def build_total_spectrum(self, dNdEdt_single, ma, ga, Erange, Ea_grid):
        """
        Retorna una función interpolada de dNdEdt_total(Ea) en todo el rango energético Ea_grid,
        sumando las contribuciones de todas las SNs.
        """
        total_flux = np.zeros_like(Ea_grid, dtype=np.float64)

        for E1, E2, dSN in Erange:
            if E2 - E1 < 1e-5:
            	continue
            	
            try:
            	Ea_local = np.linspace(E1, E2, 50)
            	spectrum_SN = dNdEdt_single(Ea_local, ma, ga)
            	weight = 1.0 / (4 * np.pi * (dSN * self.kpctocm)**2)
            	weighted = spectrum_SN * weight
            
            	# Interpola esta contribución en Ea_grid
            	interp = interp1d(Ea_local, weighted, bounds_error=False, fill_value=0)
            	total_spectrum += interp(Ea_grid)
        
            except Exception as e:
            	print(f"SN fallida en rango {E1:.3f}–{E2:.3f}: {e}")
            	continue
            	
        total_spectrum = np.nan_to_num(total_spectrum, nan=0.0, posinf=0.0, neginf=0.0)
        
        return interp1d(Ea_grid, total_spectrum, bounds_error=False, fill_value=0)


        
    def total_flux_texposureX(self, dNdEdt_single, ma, ga, Erange, Ea_grid, Nmin=5, Nmax=200):
        """
        Builds the function dflux/dE * t_exposure as the sum of each SN contribution
        for each energy range (E1, E2) and distance to Earth dSN.
        """
        total_spectrum = np.zeros_like(Ea_grid, dtype=np.float64)

        for (E1, E2, dSN) in Erange:
        	deltaE = E2 - E1

        	if not np.isfinite(E1) or not np.isfinite(E2) or not np.isfinite(dSN):
        		continue

        	if not np.isfinite(deltaE) or deltaE <= 0 or dSN <= 0:
        		continue

        	# Varying range (minimum range of 0.01 MeV per point)
        	Npoints = max(Nmin, min(Nmax, int((deltaE / 0.01) + 1)))


        	try:
        		Ea_local = np.linspace(E1, E2, Npoints)
        		spectrum_local = dNdEdt_single(Ea_local, ma, ga)

        		# Check there are no NaNs
        		spectrum_local = np.nan_to_num(spectrum_local, nan=0.0, posinf=0.0, neginf=0.0)

        		weight = 1.0 / (4 * np.pi * (dSN * self.kpctocm)**2) # dSN in kpc → cm
        		weighted = spectrum_local * weight * self.Deltat * self.stoMeVminus1 # cm^-2 MeV^-1

        		# Interpola en la grilla común
        		interp = interp1d(Ea_local, weighted, bounds_error=False, fill_value=0)
        		total_spectrum += interp(Ea_grid)

        	except Exception as e:
        		continue

        total_spectrum = np.nan_to_num(total_spectrum, nan=0.0, posinf=0.0, neginf=0.0)

        return interp1d(Ea_grid, total_spectrum, bounds_error=False, fill_value=0)



    def total_flux_texposure(self, dNdEdt_single, ma, ga, Erange):
        """
        Builds the function dflux/dE * t_exposure as the sum of each SN contribution
        for each energy range (E1, E2) and distance to Earth dSN.
        """
        # Erange to array
        Erange_arr = np.array(Erange)  # shape (N, 3)

        def total_dNdEdt(Ea):
        	Ea = np.atleast_1d(Ea)	
        	result = np.zeros_like(Ea, dtype=np.float64)

        	for i, ea in enumerate(Ea):	
        		total = 0.0
        		for E1, E2, dSN in Erange_arr:
        			if E1 <= ea <= E2:
        				try:
        					val = dNdEdt_single(ea, ma, ga)
        					weight = 1.0 / (4 * np.pi * (dSN * self.kpctocm)**2)  # dSN in kpc → cm
        					total += val * weight 
        				except Exception as e:
        					continue
        		result[i] = total * self.Deltat * self.stoMeVminus1 # cm^-2 MeV^-1
        	return result[0] if result.size == 1 else result

        return total_dNdEdt 
        
        
        
    def ZthobsXX(self, ma, ga, dNdEdt_single, Ntargets, exptime, bins, Bth, Nobs, Erange):
        # Step 1: Same energies
        Ea_grid = np.linspace(min(e[0] for e in Erange), max(e[1] for e in Erange), 300)

        # Step 2: Total interpolated spectrum
        dNdEdt_total = self.build_total_spectrumX(dNdEdt_single, ma, ga, Erange, Ea_grid)

        # Step 3: Compute Sth bin by bin using the fast integration function
        Sth = []
        for i in range(len(bins) - 1):
        	E1, E2 = bins[i], bins[i+1]
        	Ebin = 0.5 * (E1 + E2)

        	if E1 <= ma:
        		Sth.append((Ebin, 0))
        		continue

        	Egamma_vals = np.linspace(E1, E2, 60)
        	dN_vals = np.array([self.dNgammadEgamma_fast(Eg, ma, ga, dNdEdt_total) for Eg in Egamma_vals])
        	S_bin = Ntargets * exptime * self.stoMeVminus1 * np.trapz(dN_vals, Egamma_vals)
        	Sth.append((Ebin, S_bin))

        Sth = np.array(Sth)

        # Step 4: test statistic
        qmaOBS = 2 * np.sum(
        (Bth[:, 1] + Sth[:, 1]) - Nobs[:, 1] +
        Nobs[:, 1] * np.log(Nobs[:, 1] / (Bth[:, 1] + Sth[:, 1]))
        )

        dof = max(1, len(bins) - 2)
        CL = 1 - chi2.cdf(qmaOBS, dof)
        ZmaOBS = np.abs(norm.ppf(CL))

        return [99 if np.isinf(ZmaOBS) else ZmaOBS]
    
    
    

class ALPphotonDET_multi:
    def __init__(self, Cap, Deltat, diffSNfactor, diffSNfactor_X):
        self.mn = Constants.mn
        self.ee = Constants.ee
        
        self.stoMeVminus1 = Units.stoMeVminus1
        self.cmminus1toMeV = Units.cmminus1toMeV
        
        self.Cap = Cap
        self.Deltat = Deltat
        self.diffSNfactor = diffSNfactor
        self.diffSNfactor_X = diffSNfactor_X
        


    def E_gamma_max(self, Ea, ma):
        return (ma**2 + 2 * Ea * self.mn) / (2 * (self.mn + Ea) - 2 * np.sqrt(Ea**2 - ma**2))

    def E_gamma_min(self, Ea, ma):
        return (ma**2 + 2 * Ea * self.mn) / (2 * (self.mn + Ea) + 2 * np.sqrt(Ea**2 - ma**2))

    def costheta0(self, E_gamma, Ea, ma, mA):
        return (2 * E_gamma * (mA + Ea) - 2 * mA * Ea - ma**2) / (2 * np.sqrt(Ea**2 - ma**2) * E_gamma)
        
        
    def M2(self, E_gamma, Ea, ma, ga):
        J = 1 / 2

        numerator = (2 * self.Cap**2 * self.ee**2 * ga**2 *
                     (E_gamma * ma**6 + ma**4 * (2 * Ea * E_gamma + ma**2) * self.mn +
                      4 * (Ea - E_gamma) * ma**2 * ((Ea - E_gamma) * E_gamma + ma**2) * self.mn**2 +
                      4 * (Ea - E_gamma)**2 * (2 * Ea * E_gamma + ma**2) * self.mn**3))

        denominator = (E_gamma**2 * (ma**2 + 2 * Ea * self.mn)**2 * (self.mn + 2 * J * self.mn))

        return numerator / denominator

    def dSigma_dEgamma(self, E_gamma, Ea, ma, ga):
        return (1 / (32 * np.pi * self.mn * (Ea**2 - ma**2))) * self.M2(E_gamma, Ea, ma, ga)
        

    def Eamin(self, Egamma, ma):
        term1 = 2 * Egamma**2 * self.mn + ma**2 * self.mn
        term2 = Egamma * (-ma**2 - 2 * self.mn**2 + np.sqrt(ma**4 + 4 * ma**2 * (Egamma - self.mn) * self.mn + 4 * Egamma**2 * self.mn**2))
        return (term1 + term2) / (2 * (2 * Egamma - self.mn) * self.mn)

    def Eamax(self, Egamma, ma):
        sqrt_term = np.sqrt(ma**4 + 4 * ma**2 * (Egamma - self.mn) * self.mn + 4 * Egamma**2 * self.mn**2)
        numerator = ((Egamma - self.mn) * (- ma**2 + 2 * Egamma * self.mn)) / (2 * Egamma - self.mn) + Egamma * sqrt_term / np.abs(2 * Egamma - self.mn)
        return numerator / (2 * self.mn)


    def dNgammadEgamma(self, Egamma, ma, ga, dNdEdt):
        """ dNγ/dEγ """
        integral_result, _ = quad(
            lambda Ea: max(0, dNdEdt(Ea, ma, ga)) * self.dSigma_dEgamma(Egamma, Ea, ma, ga) if Ea > ma else 0,
            self.Eamin(Egamma, ma),
            self.Eamax(Egamma, ma), 
            epsrel=1e-2, epsabs=1e-2
        )
        return self.stoMeVminus1 * self.cmminus1toMeV**2 * self.Deltat * self.diffSNfactor * integral_result


    def Zthobs(self, ma, ga, dNdEdt, Ntargets, exptime, bins, Bth, Nobs):
        """ 
        # ma: axion mass,
        # ga: axion coupling,
        # dNgamdEgam: photon spectrum, as a function of Ea and ma; dNgammadEgamma[Ea, ma, ga],
        # Ntargets: number of targets in the detector,
        # exptime: exposure time of the considered experimental RUN, in seconds,
        # bins: list of energy bins,
        # Bth: number of EXPECTED background events per bin,
        # Nobs: number of OBSERVED events per bin 
        """
        
        Sth_aux = np.array([
            ((bins[i] + bins[i + 1]) / 2,
             quad(lambda x: Ntargets * exptime * self.dNgammadEgamma(x, ma, ga, dNdEdt), bins[i], bins[i + 1], epsrel=1e-2, epsabs=1e-2)[0]
             if bins[i] > ma else 0)
            for i in range(len(bins) - 1)
        ])

        ZmaOBS = []
        for factor in self.diffSNfactor_X:
            Sth = Sth_aux.copy()
            Sth[:, 1] *= factor / self.diffSNfactor

            qmaOBS = 2 * np.sum((Bth[:, 1] + Sth[:, 1]) - Nobs[:, 1] +
                                Nobs[:, 1] * np.log(Nobs[:, 1] / (Bth[:, 1] + Sth[:, 1])))

            if len(bins) > 2:
            	dof = len(bins) - 2
            else:
            	dof = 1
            CL = 1 - chi2.cdf(qmaOBS, dof)
            ZmaOBS.append(np.abs(norm.ppf(CL)))

        Zs = [99 if np.isinf(z) else z for z in ZmaOBS]

        return Zs

